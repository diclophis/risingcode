<!doctype html>
<html>
  <head>
    <title>webgl</title>
    <style type="text/css">
      body { background-color: #ffffff; }
      div { width: 100px; height: 100px; border: 2px solid red; }
    </style>
  </head>
  <body>
    <div id="rtt"></div>
    <div id="bg"></div>
    <script type="text/javascript" src="three.js"></script>

    <!-- Convolution fragment shader -->
    <script id="fs-convolution" type="x-shader/x-fragment">
      varying vec2 vUv;

      uniform sampler2D tDiffuse;
      uniform vec2 uImageIncrement;

      #define KERNEL_SIZE 25
      uniform float cKernel[KERNEL_SIZE];

      void main(void) {
        vec2 imageCoord = vUv;
        vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );
        for( int i=0; i < KERNEL_SIZE; ++i ) {
          sum += texture2D( tDiffuse, imageCoord ) * cKernel[i];
          imageCoord += uImageIncrement;
        }
        gl_FragColor = sum;
      }
    </script>

    <!-- Convolution vertex shader -->
    <script id="vs-convolution" type="x-shader/x-vertex">
      varying vec2 vUv;

      uniform vec2 uImageIncrement;
      #define KERNEL_SIZE 25.0

      void main(void) {
        //vUv = vec2( uv.x, 1.0 - uv.y ) - ((KERNEL_SIZE - 1.0) / 2.0) *
        uImageIncrement;
        vUv = uv - ((KERNEL_SIZE - 1.0) / 2.0) * uImageIncrement;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <!-- Render parameter modulated texture fragment shader -->
    <script id="fs-screen" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform float opacity;

      void main(void) {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
      }
    </script>

    <!-- Generic vertex shader -->
    <script id="vs-generic" type="x-shader/x-vertex">
      varying vec2 vUv;

      void main() {
        vUv = vec2( uv.x, 1.0 - uv.y );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>


    <script type="text/javascript">
    var ShaderTest = {
    'hatching' : {
      uniforms: {
        "uDirLightPos":     { type: "v3", value: new THREE.Vector3() },
        "uDirLightColor": { type: "c", value: new THREE.Color( 0xeeeeee ) },
        "uAmbientLightColor": { type: "c", value: new THREE.Color( 0x050505 ) },
        "uBaseColor":  { type: "c", value: new THREE.Color( 0xffffff ) },
        "uLineColor1": { type: "c", value: new THREE.Color( 0x000000 ) },
        "uLineColor2": { type: "c", value: new THREE.Color( 0x000000 ) },
        "uLineColor3": { type: "c", value: new THREE.Color( 0x000000 ) },
        "uLineColor4": { type: "c", value: new THREE.Color( 0x000000 ) }
      },
      vertex_shader: [
        "varying vec3 vNormal;",
        "void main() {",
          "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
          "vNormal = normalize( normalMatrix * normal );",
        "}"
      ].join("\n"),
      fragment_shader: [
        "uniform vec3 uBaseColor;",
        "uniform vec3 uLineColor1;",
        "uniform vec3 uLineColor2;",
        "uniform vec3 uLineColor3;",
        "uniform vec3 uLineColor4;",
        "uniform vec3 uDirLightPos;",
        "uniform vec3 uDirLightColor;",
        "uniform vec3 uAmbientLightColor;",
        "varying vec3 vNormal;",
        "void main() {",
          "float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);",
          "vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;",
          "gl_FragColor = vec4( uBaseColor, 1.0 );",
          "if ( length(lightWeighting) < 1.00 ) {",
            "if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {",
              "gl_FragColor = vec4( uLineColor1, 1.0 );",
            "}",
          "}",
          "if ( length(lightWeighting) < 0.75 ) {",
            "if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {",
              "gl_FragColor = vec4( uLineColor2, 1.0 );",
            "}",
          "}",
          "if ( length(lightWeighting) < 0.50 ) {",
            "if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {",
              "gl_FragColor = vec4( uLineColor3, 1.0 );",
            "}",
          "}",
          "if ( length(lightWeighting) < 0.3465 ) {",
            "if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {",
              "gl_FragColor = vec4( uLineColor4, 1.0 );",
            "}",
          "}",
        "}"
      ].join("\n")
    }
    };

    var container, stats;
    var cameraOrtho, cameraPerspective, sceneRTT, sceneScreen, sceneBG, renderers, mesh, directionalLight;
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;
    var rtTexture, materialScreen, materialConvolution, blurx, blury, quadBG, quadScreen;

      container = document.body;

      cameraOrtho = new THREE.Camera();
      //cameraOrtho.projectionMatrix = THREE.Matrix4.makeOrtho(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000);
      cameraOrtho.projectionMatrix = THREE.Matrix4.makeOrtho(100.0 / - 2, 100.0 / 2, 100.0 / 2, 100.0 / - 2, -10000, 10000);
      cameraOrtho.position.z = 100;

      //cameraPerspective = new THREE.Camera(50, window.innerWidth / window.innerHeight, 1, 10000);
      cameraPerspective = new THREE.Camera(50, 100.0 / 100.0, 1, 10000);
      cameraPerspective.position.z = 900;

      sceneRTT = new THREE.Scene();
      sceneScreen = new THREE.Scene();
      sceneBG = new THREE.Scene();

      directionalLight = new THREE.DirectionalLight(0xffffff);
      directionalLight.position.x = 0;
      directionalLight.position.y = 0;
      directionalLight.position.z = 1;
      directionalLight.position.normalize();
      sceneRTT.addLight(directionalLight);

      rtTexture1 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter });
      rtTexture2 = new THREE.WebGLRenderTarget(256, 512, { min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter });
      rtTexture3 = new THREE.WebGLRenderTarget(512, 256, { min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter });

      materialScreen = new THREE.MeshShaderMaterial({
        uniforms: { tDiffuse: { type: "t", value: 0, texture: rtTexture1 },
          opacity: { type: "f", value: 0.4 }
        },
        vertex_shader: document.getElementById('vs-generic').textContent,
        fragment_shader: document.getElementById('fs-screen').textContent,
        blending: THREE.AdditiveBlending
      });

      var kernel = buildKernel(4.0);

      blurx = new THREE.Vector2(0.001953125, 0.0),
      blury = new THREE.Vector2(0.0, 0.001953125);

      materialConvolution = new THREE.MeshShaderMaterial({

        uniforms: { tDiffuse: { type: "t", value: 0, texture: rtTexture1 },
          uImageIncrement: { type: "v2", value: blury },
          cKernel: { type: "fv1", value: kernel }
        },
        vertex_shader: document.getElementById('vs-convolution').textContent,
        fragment_shader: document.getElementById('fs-convolution').textContent

      });

      //var plane = new Plane(window.innerWidth, window.innerHeight);
      //var plane = new THREE.Mesh( new THREE.PlaneGeometry(200, 200), new THREE.MeshBasicMaterial( { color: 0xe0e0e0 } ) );
      var plane = new THREE.PlaneGeometry(200, 200);

      shader = ShaderTest["hatching"];

      material1 = new THREE.MeshShaderMaterial({
        uniforms: THREE.UniformsUtils.clone(shader.uniforms),
        vertex_shader: shader.vertex_shader,
        fragment_shader: shader.fragment_shader
      });

      material2 = new THREE.MeshShaderMaterial({
        uniforms: THREE.UniformsUtils.clone(shader.uniforms),
        vertex_shader: shader.vertex_shader,
        fragment_shader: shader.fragment_shader
      });

      material1.uniforms.uDirLightPos.value = material2.uniforms.uDirLightPos.value = directionalLight.position;
      material2.uniforms.uDirLightColor.value = material2.uniforms.uDirLightColor.value = directionalLight.color;

      var lineColor1 = 0xff0000, lineColor2 = 0x0000ff;
      material1.uniforms.uBaseColor.value.setHex(0x000000);
      material1.uniforms.uLineColor1.value.setHex(lineColor1);
      material1.uniforms.uLineColor2.value.setHex(lineColor1);
      material1.uniforms.uLineColor3.value.setHex(lineColor1);
      material1.uniforms.uLineColor4.value.setHex(0xffff00);

      material2.uniforms.uBaseColor.value.setHex(0x000000);
      material2.uniforms.uLineColor1.value.setHex(lineColor2);
      material2.uniforms.uLineColor2.value.setHex(lineColor2);
      material2.uniforms.uLineColor3.value.setHex(lineColor2);
      material2.uniforms.uLineColor4.value.setHex(0x00ffff);

      loader = new THREE.Loader(true);
      //document.body.appendChild(loader.statusDomElement);

      //loader.loadAscii({ model: "../shared/leeperrysmith/LeePerrySmith.js",
      //  callback: function(geometry) {
        materials = [];
        for (i = 0; i < 6; i ++ ) {
          materials.push( [ new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) ] );
        }
          //createMesh(new THREE.CubeGeometry(1000, 1000, 1000, 1, 1, 1), sceneRTT, 100)

        cube = new THREE.Mesh( new THREE.CubeGeometry(200, 200, 200, 1, 1, 1, materials), new THREE.MeshFaceMaterial() );
        cube.overdraw = true;
        sceneRTT.addObject( cube );
        cube2 = new THREE.Mesh( new THREE.CubeGeometry(200, 200, 200, 1, 1, 1, materials), new THREE.MeshFaceMaterial() );
        cube2.overdraw = true;
        sceneRTT.addObject( cube2 );

      loader.statusDomElement.style.display = "none";


      //  } });

      //quadScreen = new THREE.Mesh(plane, materialConvolution);
      //quadScreen.position.z = -100;
      //sceneScreen.addObject(quadScreen);

      renderers = new Array();
      divs = document.getElementsByTagName("div");
      for (i = 0; i<divs.length; i++) {
        //renderers[i] = new THREE.WebGLRenderer();
        a = new THREE.CanvasRenderer();
        renderers[i] = a
        renderers[i].setSize(100.0, 100.0);
        renderers[i].autoClear = false;
      }

      document.getElementById("rtt").appendChild(renderers[0].domElement);
      document.getElementById("bg").appendChild(renderers[1].domElement);

    function createMesh(geometry, scene, scale) {
/*
      var mesh1 = new THREE.Mesh(geometry, material1);
      mesh1.scale.x = mesh1.scale.y = mesh1.scale.z = scale;
      mesh1.position.x = -300;
      mesh1.position.y = -50;
      scene.addObject(mesh1);

      mesh = new THREE.Mesh(geometry, material2);
      mesh.scale.x = mesh.scale.y = mesh.scale.z = scale;
      mesh.rotation = mesh1.rotation;
      mesh.position.x = 300;
      mesh.position.y = -50;
      scene.addObject(mesh);

      loader.statusDomElement.style.display = "none";
*/
    }

    /*****************************************************************************************/
    // Convolution
    //  - ported from o3d convolution shader sample
    //      http://o3d.googlecode.com/svn/trunk/samples/convolution.html
    /*****************************************************************************************/

      // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.
    function gauss(x, sigma) {
      return Math.exp(- (x * x) / (2.0 * sigma * sigma));
    }

    function buildKernel(sigma) {

      var kMaxKernelSize = 25;
      var kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;
      if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;
      var halfWidth = ( kernelSize - 1 ) * 0.5

      var values = new Array(kernelSize);
      var sum = 0.0;
      for (var i = 0; i < kernelSize; ++i) {

        values[ i ] = gauss(i - halfWidth, sigma);
        sum += values[ i ];

      }

      // normalize the kernel
      for (var i = 0; i < kernelSize; ++i) values[ i ] /= sum;
      return values;
    }
    </script>
    <script type="text/javascript">
      (function main() {
        now = last = new Date;
/*
        tune = 0.0;
        camera = new THREE.Camera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.x = 500;
        camera.position.y = 500;
        camera.position.z = 500;
        scene = new THREE.Scene();
        materials = [];
        for (i = 0; i < 6; i ++ ) {
          materials.push( [ new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) ] );
        }
        cube = new THREE.Mesh( new THREE.CubeGeometry(200, 200, 200, 1, 1, 1, materials), new THREE.MeshFaceMaterial() );
        cube.overdraw = true;
        scene.addObject( cube );
        cube2 = new THREE.Mesh( new THREE.CubeGeometry(200, 200, 200, 1, 1, 1, materials), new THREE.MeshFaceMaterial() );
        cube2.overdraw = true;
        cube2.position.x = cube2.position.y = cube2.position.z = -300.0;
        scene.addObject( cube2 );
        plane = new THREE.Mesh( new THREE.PlaneGeometry(200, 200), new THREE.MeshBasicMaterial( { color: 0xe0e0e0 } ) );
        plane.rotation.x = - 90 * (Math.PI / 180);
        plane.overdraw = true;
        scene.addObject( plane );
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth / 2, window.innerHeight / 2);
        document.body.appendChild( renderer.domElement );
*/
      })();
      (function simulate_and_wait() {
        (function wait() {
          return function(callback) {
            //window.setTimeout(callback, tune)
          };
        })()(simulate_and_wait);
      })();
      (function render_and_vsync() {
        now = + new Date;

        if (now != last) {
          dt = now - last;
          last = now;
/*
          plane.rotation.z = cube.rotation.y += 0.005 * dt;
          cube.position.y = Math.sin(now * 0.01) * 100.0;
          camera.target.position = cube2.position;
*/
        } else {
          tune += 5.0;
        }

//        renderer.render(scene, camera);


      // Render scene into texture


      renderers[1].clear();
      //renderers[1].context.disable(renderers[2].context.DEPTH_TEST);
      //renderers[1].render(sceneBG, cameraOrtho);
      //renderers[1].render(sceneBG, cameraOrtho, rtTexture1);
      //renderers[1].context.enable(renderers[2].context.DEPTH_TEST);

      //document.getElementById("bg").appendChild(renderer.domElement);
      //renderer.render(sceneRTT, cameraPerspective);

      renderers[0].clear();
      renderers[0].render(sceneRTT, cameraPerspective);
      renderers[0].render(sceneRTT, cameraPerspective, rtTexture1);

      // Render quad with blured scene into texture (convolution pass 1)

      //quadScreen.materials = [ materialConvolution ];
      //materialConvolution.uniforms.tDiffuse.texture = rtTexture1;
      //materialConvolution.uniforms.uImageIncrement.value = blurx;
      //renderer.render(sceneScreen, cameraOrtho, rtTexture2);

      // Render quad with blured scene into texture (convolution pass 2)

      //materialConvolution.uniforms.tDiffuse.texture = rtTexture2;
      //materialConvolution.uniforms.uImageIncrement.value = blury;
      //renderer.render(sceneScreen, cameraOrtho, rtTexture3);

      // Render original scene with superimposed blur to texture

      //quadScreen.materials = [ materialScreen ];

      //materialScreen.uniforms.tDiffuse.texture = rtTexture3;
      //materialScreen.uniforms.opacity.value = 1.5;
      //renderer.render(sceneScreen, cameraOrtho, rtTexture1, false);

      // Render to screen

      //materialScreen.uniforms.tDiffuse.texture = rtTexture1;

      //renderer.render(sceneScreen, cameraOrtho);

        (function vsync() {
          return window.requestAnimationFrame || 
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame || 
          window.oRequestAnimationFrame || 
          window.msRequestAnimationFrame || 
          function(callback, element){
            window.setTimeout(callback, 1000 / 60);
          };
        })()(render_and_vsync);
      })();
    </script>
  </body>
</html>
