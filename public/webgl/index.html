<!doctype html>
<html>
  <head>
    <title>webgl</title>
    <style type="text/css">
      body { background-color: #ffffff; overflow: hidden; }
      img, video { display: none; }
    </style>
  </head>
  <body>
    <canvas id="canvas_spec" width="512" height="200" style="background-color:orange;"></canvas>
    <img id="disturb" src="textures/disturb.png"/>
    <link id="mindkick" href="phuture_sounds.mod"/>
    <script type="text/javascript" src="three.js"></script>
    <script type="text/javascript" src="modfile.js"></script>
    <script type="text/javascript" src="modplayer.js"></script>
    <script type="text/javascript" src="swfobject.js"></script>
    <script type="text/javascript" src="dynamicaudio.js"></script>
    <script type="text/javascript" src="fft.js"></script>
    <script id="fs-convolution" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform vec2 uImageIncrement;
      #define KERNEL_SIZE 25
      uniform float cKernel[KERNEL_SIZE];
      void main(void) {
        vec2 imageCoord = vUv;
        vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );
        for( int i=0; i < KERNEL_SIZE; ++i ) {
          sum += texture2D( tDiffuse, imageCoord ) * cKernel[i];
          imageCoord += uImageIncrement;
        }
        gl_FragColor = sum;
      }
    </script>
    <script id="vs-convolution" type="x-shader/x-vertex">
      varying vec2 vUv;
      uniform vec2 uImageIncrement;
      #define KERNEL_SIZE 25.0
      void main(void) {
        uImageIncrement;
        vUv = uv - ((KERNEL_SIZE - 1.0) / 2.0) * uImageIncrement;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>
    <script id="fs-screen" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform float opacity;
      void main(void) {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
      }
    </script>
    <script id="vs-generic" type="x-shader/x-vertex">
      varying vec2 vUv;
      void main() {
        vUv = vec2( uv.x, 1.0 - uv.y );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>
    <script id="fragment_shader4" type="x-shader/x-fragment">
      uniform float time;
      uniform vec2 resolution;
      varying vec2 vUv;
      void main( void ) {
        vec2 position = -1.0 + 2.0 * vUv;
        float red = abs( sin( position.x * position.y + time / 5.0 ) );
        float green = abs( sin( position.x * position.y + time / 4.0 ) );
        float blue = abs( sin( position.x * position.y + time / 3.0 ) );
        gl_FragColor = vec4( red, green, blue, 1.0 );
      }
    </script>
    <script id="fragment_shader3" type="x-shader/x-fragment">
      uniform float time;
      uniform vec2 resolution;
      varying vec2 vUv;
      void main( void ) {
        vec2 position = vUv;
        float color = 0.0;
        color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
        color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
        color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
        color *= sin( time / 10.0 ) * 0.5;
        gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );
      }
    </script>
    <script id="fragment_shader2" type="x-shader/x-fragment">
      uniform float time;
      uniform vec2 resolution;
      uniform sampler2D texture;
      varying vec2 vUv;
      void main( void ) {
        vec2 position = -1.0 + 2.0 * vUv;
        float a = atan( position.y, position.x );
        float r = sqrt( dot( position, position ) );
        vec2 uv;
        uv.x = cos( a ) / r;
        uv.y = sin( a ) / r;
        uv /= 10.0;
        uv += time * 0.05;
        vec3 color = texture2D( texture, uv ).rgb;
        gl_FragColor = vec4( color * r * 1.5, 1.0 );
      }
    </script>
    <script id="fragment_shader1" type="x-shader/x-fragment">
      #ifdef GL_ES
      precision highp float;
      #endif
      uniform vec2 resolution;
      uniform float time;
      varying vec2 vUv;
      void main(void)
      {
        vec2 p = -1.0 + 2.0 * vUv;
        float a = time*40.0;
        float d,e,f,g=1.0/40.0,h,i,r,q;
        e=400.0*(p.x*0.5+0.5);
        f=400.0*(p.y*0.5+0.5);
        i=200.0+sin(e*g+a/150.0)*20.0;
        d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;
        r=sqrt(pow(i-e,2.0)+pow(d-f,2.0));
        q=f/r;
        e=(r*cos(q))-a/2.0;f=(r*sin(q))-a/2.0;
        d=sin(e*g)*176.0+sin(e*g)*164.0+r;
        h=((f+d)+a/2.0)*g;
        i=cos(h+r*p.x/1.3)*(e+e+a)+cos(q*g*6.0)*(r+h/3.0);
        h=sin(f*g)*144.0-sin(e*g)*212.0*p.x;
        h=(h+(f-e)*q+sin(r-(a+h)/7.0)*10.0+i/4.0)*g;
        i+=cos(h*2.3*sin(a/350.0-q))*184.0*sin(q-(r*4.3+a/12.0)*g)+tan(r*g+h)*184.0*cos(r*g+h);
        i=mod(i/5.6,256.0)/64.0;
        if(i<0.0) i+=4.0;
        if(i>=2.0) i=4.0-i;
        d=r/350.0;
        d+=sin(d*d*8.0)*0.52;
        f=(sin(a*g)+1.0)/2.0;
        gl_FragColor=vec4(vec3(f*i/1.6,i/2.0+d/13.0,i)*d*p.x+vec3(i/1.3+d/8.0,i/2.0+d/18.0,i)*d*(1.0-p.x),1.0);
      }
    </script>
    <script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      void main()
      {
        vUv = uv;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * mvPosition;
      }
    </script>
    <script type="text/javascript">
      document.addEventListener("DOMContentLoaded", function () {




canvas5 = document.getElementById("canvas_spec");
context5 = canvas5.getContext('2d');
context5.strokeStyle = "#FFFFFF";
context5.lineWidth = 2;


  channels = 2; //audio5.mozChannels;
  fbLength = 4096; //audio5.mozFrameBufferLength;
  rate     = 44100; //audio5.mozSampleRate;
  //fft = new FFT(fbLength / channels, rate);
  //console.log(fft);
  fft = new FFT(fbLength / channels, 44100);

function writeSamples (samples) {
  length = samples.length / channels;
  signal = new Float32Array(length);
  for (i = 0; i < length; i++ ) {
    if (channels == 2) {
    // merge channels into a stereo-mix mono signal
      signal[i] = (samples[2*i] + samples[2*i+1]) / 2;
    } else { // assume no more than 2 channels of data
      signal[i] = samples[i];
    }
  }
  //samples.length / 2
  //fft = new FFT(length, 44100);
  fft.forward(signal);
  context5.clearRect(0,0, 512, 200);
  for (i = 0; i < fft.spectrum.length; i++ ) {
    // multiply spectrum by a zoom value
    magnitude = fft.spectrum[i] * 4000;
    // Draw rectangle bars for each frequency bin
    context5.fillRect(i * 4, canvas5.height, 3, -magnitude);
  }
}
       

        count = 0;
        now = last = new Date().getTime();

        playing = false;
        dynamicAudio = new DynamicAudio({'swf': 'dynamicaudio.swf'});

        fetch = new XMLHttpRequest();
        fetch.open('GET', document.getElementById("mindkick").href);
        fetch.overrideMimeType("text/plain; charset=x-user-defined");
        fetch.onreadystatechange = function() {
          if(this.readyState == 4 && this.status == 200) {
            /* munge response into a binary string */
            t = this.responseText || "" ;
            ff = [];
            mx = t.length;
            scc = String.fromCharCode;
            for (z = 0; z < mx; z++) {
              ff[z] = scc(t.charCodeAt(z) & 255);
            }
            binString = ff.join("");
            modFile = new ModFile(binString);
            modPlayer = new ModPlayer(modFile, 44100);
            //// initially buffer 10 seconds (44100 * 2(stereo) * 10)
            //dynamicAudio.write(modPlayer.getSamples(44100 * 2 * 1));

            playing = true;
          }
        }
        fetch.send();


        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        meshes = [];

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        //-5, 5, 5, -5
        //cameraOrtho = new THREE.OrthoCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000)
        cameraOrtho = new THREE.OrthoCamera(-15, 15, 15, -15, -10000, 10000)
        cameraOrtho.position.z = 0;

        cameraPerspective = new THREE.Camera(50, window.innerWidth / window.innerHeight, 1, 10000);
        cameraPerspective.position.z = 4;

        scene = new THREE.Scene();
        sceneBG = new THREE.Scene();
        sceneRTT = new THREE.Scene();

        directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.x = 0;
        directionalLight.position.y = 0;
        directionalLight.position.z = 1;
        directionalLight.position.normalize();
        sceneRTT.addLight(directionalLight);

        start_time = new Date().getTime();

        rtTexture1 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter});
        rtTexture2 = new THREE.WebGLRenderTarget(256, 512, { min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter });
        rtTexture3 = new THREE.WebGLRenderTarget(512, 256, { min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter });

        uniforms1 = {
          time: { type: "f", value: 1.0 },
          resolution: { type: "v2", value: new THREE.Vector2() }
        };

        t = new THREE.Texture(document.getElementById("disturb"));
        //t = new THREE.Texture(document.getElementById("mandelbrot"));
        t.needsUpdate = true;

        uniforms2 = {
          time: { type: "f", value: 1.0 },
          resolution: { type: "v2", value: new THREE.Vector2() },
          texture: { type: "t", value: 0, texture: t }
        };

        uniforms2.texture.texture.wrapS = uniforms2.texture.texture.wrapT = THREE.Repeat;

        size = 0.75, mlib = [],
        params = [['fragment_shader1', uniforms1],  ['fragment_shader2', uniforms2], [ 'fragment_shader3', uniforms1 ], [ 'fragment_shader4', uniforms1 ] ];

          //vt = new THREE.Texture(document.getElementById("mandelbrot"));
          //vt.needsUpdate = true;
          //parameters = { color: 0xffffff, map: vt };
          //material = new THREE.MeshLambertMaterial(parameters);

          //vt = new THREE.Texture(document.getElementById("mandelbrot"));
          //vt.minFilter = THREE.LinearFilter;
          //vt.magFilter = THREE.LinearFilter;
          //material = new THREE.MeshBasicMaterial({map: vt});


        for(i = 0; i < params.length; i++ ) {
          material = new THREE.MeshShaderMaterial({
            uniforms: params[i][1],
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById(params[ i ][ 0 ]).textContent
          });
          mlib[i] = material;
          mesh = new THREE.Mesh( new THREE.CubeGeometry( size, size, size, 1, 1, 1, [ mlib[ i ], mlib[ i ], mlib[ i ], mlib[ i ], mlib[ i ], mlib[ i ] ], false ), new THREE.MeshFaceMaterial() );
          //mesh = new THREE.Mesh(new THREE.CubeGeometry(size, size, size), material);
          mesh.position.x = i - ( params.length - 1 ) / 2;
          mesh.position.y = i % 2 - 0.5;
          sceneRTT.addObject(mesh);
          meshes[i] = mesh;
        }

        uniforms1.resolution.value.x = window.innerWidth;
        uniforms1.resolution.value.y = window.innerHeight;

        uniforms2.resolution.value.x = window.innerWidth;
        uniforms2.resolution.value.y = window.innerHeight;

        gauss = function(x, sigma) {
          return Math.exp(- (x * x) / (2.0 * sigma * sigma));
        };

        materialScreen = new THREE.MeshShaderMaterial({
          uniforms: { tDiffuse: { type: "t", value: 0, texture: rtTexture1 },
            opacity: { type: "f", value: 0.4 }
          },
          vertexShader: document.getElementById('vs-generic').textContent,
          fragmentShader: document.getElementById('fs-screen').textContent,
          blending: THREE.AdditiveBlending
        });
        console.log(document.getElementById('disturb').textContent)

        blurx = new THREE.Vector2(0.001953125, 0.0);
        blury = new THREE.Vector2(0.0, 0.001953125);
        kernel = (function buildKernel(sigma) {
          kMaxKernelSize = 25;
          kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;
          if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;
          halfWidth = ( kernelSize - 1 ) * 0.5
          values = new Array(kernelSize);
          sum = 0.0;
          for (i = 0; i < kernelSize; ++i) {
            values[ i ] = gauss(i - halfWidth, sigma);
            sum += values[ i ];
          }

          // normalize the kernel
          for (i = 0; i < kernelSize; ++i) values[ i ] /= sum;
          return values;
        })(4.0);

        materialConvolution = new THREE.MeshShaderMaterial({
          uniforms: { tDiffuse: { type: "t", value: 0, texture: rtTexture1 },
            uImageIncrement: { type: "v2", value: blury },
            cKernel: { type: "fv1", value: kernel }
          },
          vertexShader: document.getElementById('vs-convolution').textContent,
          fragmentShader: document.getElementById('fs-convolution').textContent
        });

        quadScreen = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), materialConvolution);
        quadScreen.overdraw = true;
        scene.addObject(quadScreen);

      (function render_and_vsync() {

        now = new Date().getTime();
        dt = now - last;
        last = now;

        if (playing) {


          //44100 hz * 2 channels * Ns
          //samples = (modPlayer.getSamples(44100 * 2 * (20 / 1000)));
          //samples = (modPlayer.getSamples(44100 * 2 * (20 / 1000)));
          //console.log(44100 * 2 * (20 / 1000));
          //sample_length = fbLength;
          //samples = (modPlayer.getSamples(fbLength));

          sample_length = (44100 * 2 * (dt / 1000));
          samples = (modPlayer.getSamples(sample_length));
          fill = new Float32Array(fbLength);
          for (i=0; i<samples.length; i++) {
            fill[i] = samples[i];
          }





          writeSamples(fill);
          dynamicAudio.write(samples);


          //quadScreen.rotation.x += 0.01;
          //quadScreen.rotation.y += 0.01;
          //quadScreen.rotation.z += 0.01;
          //cameraOrtho.position.z += 1;

          renderer.clear();

          renderer.context.disable(renderer.context.DEPTH_TEST);
          //renderer.render(sceneBG, cameraOrtho, rtTexture1);
          renderer.context.enable(renderer.context.DEPTH_TEST);

          renderer.render(sceneRTT, cameraPerspective, rtTexture1);

          // Render quad with blured scene into texture (convolution pass 1)
          quadScreen.materials = [materialConvolution];
          materialConvolution.uniforms.tDiffuse.texture = rtTexture1;
          materialConvolution.uniforms.uImageIncrement.value = blurx;
          renderer.render(scene, cameraOrtho, rtTexture2);

          // Render quad with blured scene into texture (convolution pass 2)
          materialConvolution.uniforms.tDiffuse.texture = rtTexture2;
          materialConvolution.uniforms.uImageIncrement.value = blury;
          renderer.render(scene, cameraOrtho, rtTexture3);

          // Render original scene with superimposed blur to texture
          quadScreen.materials = [materialScreen];
          materialScreen.uniforms.tDiffuse.texture = rtTexture3;
          materialScreen.uniforms.opacity.value = 1.5;
          renderer.render(scene, cameraOrtho, rtTexture1, false);

          //assign texture
          materialScreen.uniforms.tDiffuse.texture = rtTexture1;

          uniforms1.time.value += 0.05;
          uniforms2.time.value = (new Date().getTime() - start_time) / 1000;

          for(i = 0; i < meshes.length; ++i ) {
            meshes[ i ].rotation.y += 0.01 * ( i % 2 ? 1 : -1 );
            meshes[ i ].rotation.x += 0.01 * ( i % 2 ? -1 : 1 );
          }

          if (false) {
            renderer.render(scene, cameraOrtho);
          } else {
            renderer.render(sceneRTT, cameraPerspective);
          }
        }

        (function vsync() {
          return window.requestAnimationFrame || 
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame || 
          window.oRequestAnimationFrame || 
          window.msRequestAnimationFrame || 
          function(callback, element){
            window.setTimeout(callback, 1000 / 60);
          };
        })()(render_and_vsync);
      })();
      });
    </script>
  </body>
</html>
