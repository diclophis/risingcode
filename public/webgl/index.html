<!doctype html>
<html>
  <head>
    <title>webgl</title>
    <style type="text/css">
      body { margin: 0; background-color: #000000; overflow: hidden; }
      img, video { display: none; }
    </style>
  </head>
  <body>
    <canvas id="canvas_spec" width="8192" height="200" style="background-color:orange;"></canvas>
    <img id="disturb" src="textures/disturb.png"/>
    <link id="mod" href="phuture_sounds.mod"/>
    <script type="text/javascript" src="three.js"></script>
    <script type="text/javascript" src="modfile.js"></script>
    <script type="text/javascript" src="modplayer.js"></script>
    <script type="text/javascript" src="swfobject.js"></script>
    <script type="text/javascript" src="dynamicaudio.js"></script>
    <script type="text/javascript" src="fft.js"></script>
    <script id="fs-convolution" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform vec2 uImageIncrement;
      #define KERNEL_SIZE 25
      uniform float cKernel[KERNEL_SIZE];
      void main(void) {
        vec2 imageCoord = vUv;
        vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );
        for( int i=0; i < KERNEL_SIZE; ++i ) {
          sum += texture2D( tDiffuse, imageCoord ) * cKernel[i];
          imageCoord += uImageIncrement;
        }
        gl_FragColor = sum;
      }
    </script>
    <script id="vs-convolution" type="x-shader/x-vertex">
      varying vec2 vUv;
      uniform vec2 uImageIncrement;
      #define KERNEL_SIZE 25.0
      void main(void) {
        uImageIncrement;
        vUv = uv - ((KERNEL_SIZE - 1.0) / 2.0) * uImageIncrement;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>
    <script id="fs-screen" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform float opacity;
      void main(void) {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
      }
    </script>
    <script id="vs-generic" type="x-shader/x-vertex">
      varying vec2 vUv;
      void main() {
        vUv = vec2( uv.x, 1.0 - uv.y );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>
    <script id="fragment_shader4" type="x-shader/x-fragment">
      uniform float time;
      uniform vec2 resolution;
      varying vec2 vUv;
      void main( void ) {
        vec2 position = -1.0 + 2.0 * vUv;
        float red = abs( sin( position.x * position.y + time / 5.0 ) );
        float green = abs( sin( position.x * position.y + time / 4.0 ) );
        float blue = abs( sin( position.x * position.y + time / 3.0 ) );
        gl_FragColor = vec4( red, green, blue, 1.0 );
      }
    </script>
    <script id="fragment_shader3" type="x-shader/x-fragment">
      uniform float time;
      uniform vec2 resolution;
      varying vec2 vUv;
      void main( void ) {
        vec2 position = vUv;
        float color = 0.0;
        color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
        color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
        color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
        color *= sin( time / 10.0 ) * 0.5;
        gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );
      }
    </script>
    <script id="fragment_shader2" type="x-shader/x-fragment">
      uniform float time;
      uniform vec2 resolution;
      uniform sampler2D texture;
      varying vec2 vUv;
      void main( void ) {
        vec2 position = -1.0 + 2.0 * vUv;
        float a = atan( position.y, position.x );
        float r = sqrt( dot( position, position ) );
        vec2 uv;
        uv.x = cos( a ) / r;
        uv.y = sin( a ) / r;
        uv /= 10.0;
        uv += time * 0.05;
        vec3 color = texture2D( texture, uv ).rgb;
        gl_FragColor = vec4( color * r * 1.5, 1.0 );
      }
    </script>
    <script id="fragment_shader1" type="x-shader/x-fragment">
      #ifdef GL_ES
      precision highp float;
      #endif
      uniform vec2 resolution;
      uniform float time;
      varying vec2 vUv;
      void main(void)
      {
        vec2 p = -1.0 + 2.0 * vUv;
        float a = time*40.0;
        float d,e,f,g=1.0/40.0,h,i,r,q;
        e=400.0*(p.x*0.5+0.5);
        f=400.0*(p.y*0.5+0.5);
        i=200.0+sin(e*g+a/150.0)*20.0;
        d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;
        r=sqrt(pow(i-e,2.0)+pow(d-f,2.0));
        q=f/r;
        e=(r*cos(q))-a/2.0;f=(r*sin(q))-a/2.0;
        d=sin(e*g)*176.0+sin(e*g)*164.0+r;
        h=((f+d)+a/2.0)*g;
        i=cos(h+r*p.x/1.3)*(e+e+a)+cos(q*g*6.0)*(r+h/3.0);
        h=sin(f*g)*144.0-sin(e*g)*212.0*p.x;
        h=(h+(f-e)*q+sin(r-(a+h)/7.0)*10.0+i/4.0)*g;
        i+=cos(h*2.3*sin(a/350.0-q))*184.0*sin(q-(r*4.3+a/12.0)*g)+tan(r*g+h)*184.0*cos(r*g+h);
        i=mod(i/5.6,256.0)/64.0;
        if(i<0.0) i+=4.0;
        if(i>=2.0) i=4.0-i;
        d=r/350.0;
        d+=sin(d*d*8.0)*0.52;
        f=(sin(a*g)+1.0)/2.0;
        gl_FragColor=vec4(vec3(f*i/1.6,i/2.0+d/13.0,i)*d*p.x+vec3(i/1.3+d/8.0,i/2.0+d/18.0,i)*d*(1.0-p.x),1.0);
      }
    </script>
    <script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      void main()
      {
        vUv = uv;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * mvPosition;
      }
    </script>
    <script type="text/javascript">
      document.addEventListener("DOMContentLoaded", function () {
        time = 0;

        base_hit = 0;

        modPlayerSet = false;
        is_audio_ready = false;
        is_video_ready = false;

        canvas5 = document.getElementById("canvas_spec");
        context5 = canvas5.getContext('2d');
        context5.strokeStyle = "#FFFFFF";
        context5.lineWidth = 2;

        channels = 2; //audio5.mozChannels;
        fbLength = 1024 * 4;
        rate     = 44100;
        fft = new FFT(fbLength / channels, 44100);
        audio_b = [];

        synced = false;

        document.getElementById("first_toggler").onclick = function() {
          synced = !synced;
        };

        width = 2;

        window.onscroll = function () {
          width += 5;
        };

        function writeSamples (samples) {
          length = samples.length / channels;
          signal = new Float32Array(length);
          for (i = 0; i < length; i++ ) {
            if (channels == 2) {
            // merge channels into a stereo-mix mono signal
              signal[i] = (samples[2*i] + samples[2*i+1]) / 2;
            } else { // assume no more than 2 channels of data
              signal[i] = samples[i];
            }
          }
          fft.forward(signal);
          for (i = 0; i < fft.spectrum.length; i++ ) {
            context5.fillStyle = "rgba(0,0,0, 0.1)";
            magnitude = fft.spectrum[i] * 1000;
            if (i == 3 && magnitude > 70) {
              context5.fillStyle = "rgba(200,0,0, 0.5)";
              base_hit = 75;
              //context5.clearRect(0,0, fbLength, 200);
            }
            if (magnitude > 20) {
              context5.fillRect(i * width, canvas5.height, width+1, -magnitude);
            }
          }
        }

        count = 0;
        now = last = now_v = last_v = new Date().getTime();

        dynamicAudio = new DynamicAudio({'swf': 'dynamicaudio.swf'});

        fetch = new XMLHttpRequest();
        fetch.open('GET', document.getElementById("mod").href);
        fetch.overrideMimeType("text/plain; charset=x-user-defined");
        fetch.onreadystatechange = function() {
          if (this.readyState == 4 && this.status == 200) {
            /* munge response into a binary string */
            t = this.responseText || "" ;
            ff = [];
            mx = t.length;
            scc = String.fromCharCode;
            for (z = 0; z < mx; z++) {
              ff[z] = scc(t.charCodeAt(z) & 255);
            }
            binString = ff.join("");
            modFile = new ModFile(binString);
            modPlayer = new ModPlayer(modFile, 44100);
            modPlayerSet = true;
          }
        }
        fetch.send();

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        meshes = [];

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        //-5, 5, 5, -5
        //cameraOrtho = new THREE.OrthoCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000)
        cameraOrtho = new THREE.OrthoCamera(-16, 16, 16, -16, -10000, 10000)

        cameraPerspective = new THREE.Camera(50, window.innerWidth / window.innerHeight, 1, 10000);
        cameraPerspective.target.position.x = 0;
        cameraPerspective.target.position.y = 0;
        cameraPerspective.target.position.z = 0;
        cameraPerspective.position.x = 3;
        cameraPerspective.position.y = 3;
        cameraPerspective.position.z = 3;

        scene = new THREE.Scene();
        sceneRTT = new THREE.Scene();

        directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.x = 0;
        directionalLight.position.y = 0;
        directionalLight.position.z = 1;
        directionalLight.position.normalize();
        //sceneRTT.addLight(directionalLight);


        start_time = new Date().getTime();

        rtTexture1 = new THREE.WebGLRenderTarget(1024, 1024, {min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter});
        rtTexture2 = new THREE.WebGLRenderTarget(256, 512, { min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter });
        rtTexture3 = new THREE.WebGLRenderTarget(512, 256, { min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter });

        uniforms1 = {
          time: { type: "f", value: 1.0 },
          resolution: { type: "v2", value: new THREE.Vector2() }
        };

        t = new THREE.Texture(document.getElementById("disturb"));
        t.needsUpdate = true;

        uniforms2 = {
          time: { type: "f", value: 1.0 },
          resolution: { type: "v2", value: new THREE.Vector2() },
          texture: { type: "t", value: 0, texture: t }
        };

        uniforms2.texture.texture.wrapS = uniforms2.texture.texture.wrapT = THREE.Repeat;

        size = 1.0, mlib = [],
        params = [['fragment_shader1', uniforms1],  ['fragment_shader2', uniforms2], [ 'fragment_shader3', uniforms1 ], [ 'fragment_shader4', uniforms1 ] ];

        for(i = 0; i < params.length; i++ ) {
          //material = new THREE.MeshShaderMaterial({
          //  lights: true,
          //  uniforms: THREE.UniformsUtils.merge(params[i][1], THREE.UniformsLib[ "lights" ]),
          //  vertexShader: document.getElementById('vertexShader').textContent,
          //  fragmentShader: document.getElementById(params[ i ][ 0 ]).textContent
          //});
          material = new THREE.MeshPhongMaterial( { ambient: 0x030303, color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.SmoothShading } );

          mlib[i] = material;

          //mesh = new THREE.Mesh( new THREE.CubeGeometry( size, size, size, 8, 8, 8, [ mlib[ i ], mlib[ i ], mlib[ i ], mlib[ i ], mlib[ i ], mlib[ i ] ], false ), new THREE.MeshFaceMaterial() );
          mesh = new THREE.Mesh(new THREE.SphereGeometry(1, 8, 16), [material]);

          //mesh.position.x = i - ( params.length - 1 ) / 2;
          //mesh.position.z = i % 2 - 0.5;
          mesh.position.x = (i-2);
          sceneRTT.addObject(mesh);
          meshes[i] = mesh;
        }

        //plan_material = [ 
        //  new THREE.MeshBasicMaterial( { color: 0xffffff, shading: THREE.FlatShading } ),
        //  new THREE.MeshBasicMaterial( { color: 0x000000, shading: THREE.FlatShading, wireframe: true } ) 
        //];
        //plane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10, 9, 9), plan_material);
        //plane.rotation.x = -90.0 * (Math.PI / 180)
        //plane.position.x = 0;
        //plane.position.y = 0;
        //plane.position.z = 0;

        particleLight = new THREE.Mesh( new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
        //sceneRTT.addObject( particleLight );

        pointLight = new THREE.PointLight(0xffffff, 1);
        //sceneRTT.addLight(new THREE.AmbientLight(0xffffff));
        sceneRTT.addLight(pointLight);

/*
scene.addLight( new THREE.AmbientLight( 0x00000 ) );

light1 = new THREE.PointLight( 0xff0040, 2, 50 );
scene.addLight( light1 );

light2 = new THREE.PointLight( 0x0040ff, 2, 50 );
scene.addLight( light2 );

light3 = new THREE.PointLight( 0x80ff80, 2, 50 );
scene.addLight( light3 );
*/


        uniforms1.resolution.value.x = window.innerWidth;
        uniforms1.resolution.value.y = window.innerHeight;

        uniforms2.resolution.value.x = window.innerWidth;
        uniforms2.resolution.value.y = window.innerHeight;

        gauss = function(x, sigma) {
          return Math.exp(- (x * x) / (2.0 * sigma * sigma));
        };

        materialScreen = new THREE.MeshShaderMaterial({
          uniforms: { tDiffuse: { type: "t", value: 0, texture: rtTexture1 },
            opacity: { type: "f", value: 0.4 }
          },
          vertexShader: document.getElementById('vs-generic').textContent,
          fragmentShader: document.getElementById('fs-screen').textContent,
          blending: THREE.AdditiveBlending
        });

        blurx = new THREE.Vector2(0.001953125, 0.0);
        blury = new THREE.Vector2(0.0, 0.001953125);
        kernel = (function buildKernel(sigma) {
          kMaxKernelSize = 25;
          kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;
          if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;
          halfWidth = ( kernelSize - 1 ) * 0.5
          values = new Array(kernelSize);
          sum = 0.0;
          for (i = 0; i < kernelSize; ++i) {
            values[ i ] = gauss(i - halfWidth, sigma);
            sum += values[ i ];
          }

          // normalize the kernel
          for (i = 0; i < kernelSize; ++i) values[ i ] /= sum;
          return values;
        })(4.0);

        materialConvolution = new THREE.MeshShaderMaterial({
          uniforms: { tDiffuse: { type: "t", value: 0, texture: rtTexture1 },
            uImageIncrement: { type: "v2", value: blury },
            cKernel: { type: "fv1", value: kernel }
          },
          vertexShader: document.getElementById('vs-convolution').textContent,
          fragmentShader: document.getElementById('fs-convolution').textContent
        });

        quadScreen = new THREE.Mesh(new THREE.PlaneGeometry(32, 32), materialConvolution);
        quadScreen.overdraw = true;
        scene.addObject(quadScreen);

        samples = [];

        (function pump_and_wait() {
          now = new Date().getTime();
          dt = now - last;
          last = now;
          if (is_video_ready && modPlayerSet && ((typeof dynamicAudio.flashElementRef.write === "function") || dynamicAudio.audioElement)) {
            sample_length = (44100 * 2 * ((dt) / 1000));
            samples = (modPlayer.getSamples(sample_length));
            dynamicAudio.write(samples);
            audio_b = audio_b.concat(samples);
            is_audio_ready = true;
          }
          (function wait() {
            return function(callback, element){
              window.setTimeout(callback, 60);
            };
          })()(pump_and_wait);
        })();

        (function render_and_vsync() {

          now_v = new Date().getTime();
          dt = now_v - last_v;
          time += dt;
          last_v = now_v;

          if (time > 2600) {
            is_video_ready = true;
          }

          if (is_audio_ready) {
            sl = (44100 * 2 * (dt / 1000))
            //if (audio_b.length > sl) {
              chumped = audio_b.splice(0, sl);
              fill = new Float32Array(fbLength);
              for (i=0; i<chumped.length; i++) {
                fill[i] = chumped[i];
              }
              writeSamples(fill);
            //}
            if (synced) {
              modPlayer.setBpm(10);
            } else {
              modPlayer.setBpm(125);
            }
          }
          renderer.render(sceneRTT, cameraPerspective, rtTexture1);

          // Render quad with blured scene into texture (convolution pass 1)
          quadScreen.materials = [materialConvolution];
          materialConvolution.uniforms.tDiffuse.texture = rtTexture1;
          materialConvolution.uniforms.uImageIncrement.value = blurx;
          renderer.render(scene, cameraOrtho, rtTexture2);

          // Render quad with blured scene into texture (convolution pass 2)
          materialConvolution.uniforms.tDiffuse.texture = rtTexture2;
          materialConvolution.uniforms.uImageIncrement.value = blury;
          renderer.render(scene, cameraOrtho, rtTexture3);

          // Render original scene with superimposed blur to texture
          quadScreen.materials = [materialScreen];
          materialScreen.uniforms.tDiffuse.texture = rtTexture3;
          materialScreen.uniforms.opacity.value = 1.5;
          renderer.render(scene, cameraOrtho, rtTexture1, false);

          //assign texture
          materialScreen.uniforms.tDiffuse.texture = rtTexture1;

          uniforms1.time.value += 0.05;
          uniforms2.time.value = (new Date().getTime() - start_time) / 1000;


          r = Math.floor(Math.random() * 4.0);


          particleLight.position.x = Math.sin(time * 0.001) * 2;
          particleLight.position.y = Math.cos(time * 0.001) * 2;
          particleLight.position.z = Math.cos(time * 0.001) * 2;

          pointLight.position.x = particleLight.position.x;
          pointLight.position.y = particleLight.position.y;
          pointLight.position.z = particleLight.position.z;


          for(i = 0; i < meshes.length; ++i ) {
            spin = 0.01;
            if (base_hit > 0) {
              if (i === r) {
                spin = 0.15;
              }
            }
            //meshes[ i ].rotation.y += spin * ( i % 2 ? 1 : -1 );
            //meshes[ i ].rotation.x += spin * ( i % 2 ? -1 : 1 );
          }

          if (base_hit > 0) {
            base_hit -= dt;
          } else {
          }

        

            //renderer.render(scene, cameraOrtho);
            renderer.render(sceneRTT, cameraPerspective);

          (function vsync() {
            return window.requestAnimationFrame || 
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame || 
            window.oRequestAnimationFrame || 
            window.msRequestAnimationFrame || 
            function(callback, element){
              window.setTimeout(callback, 1000 / 60);
            };
          })()(render_and_vsync);
        })();
      });
    </script>
    <button id="first_toggler">foo</button>
  </body>
</html>
