<!doctype html>
<html>
  <head>
    <title>webgl</title>
    <style type="text/css">
      body { background-color: #ffffff; }
      div { width: 100px; height: 100px; border: 2px solid red; }
    </style>
  </head>
  <body>
    <script type="text/javascript" src="three.js"></script>

    <!-- Convolution fragment shader -->
    <script id="fs-convolution" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform vec2 uImageIncrement;
      #define KERNEL_SIZE 25
      uniform float cKernel[KERNEL_SIZE];
      void main(void) {
        vec2 imageCoord = vUv;
        vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );
        for( int i=0; i < KERNEL_SIZE; ++i ) {
          sum += texture2D( tDiffuse, imageCoord ) * cKernel[i];
          imageCoord += uImageIncrement;
        }
        gl_FragColor = sum;
      }
    </script>

    <!-- Convolution vertex shader -->
    <script id="vs-convolution" type="x-shader/x-vertex">
      varying vec2 vUv;
      uniform vec2 uImageIncrement;
      #define KERNEL_SIZE 25.0
      void main(void) {
        //vUv = vec2( uv.x, 1.0 - uv.y ) - ((KERNEL_SIZE - 1.0) / 2.0) *
        uImageIncrement;
        vUv = uv - ((KERNEL_SIZE - 1.0) / 2.0) * uImageIncrement;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <!-- Render parameter modulated texture fragment shader -->
    <script id="fs-screen" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform float opacity;
      void main(void) {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
      }
    </script>

    <!-- Generic vertex shader -->
    <script id="vs-generic" type="x-shader/x-vertex">
      varying vec2 vUv;
      void main() {
        vUv = vec2( uv.x, 1.0 - uv.y );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

        <script id="fragment_shader4" type="x-shader/x-fragment">

            uniform float time;
            uniform vec2 resolution;

            varying vec2 vUv;

            void main( void ) {

                vec2 position = -1.0 + 2.0 * vUv;

                float red = abs( sin( position.x * position.y + time / 5.0 ) );
                float green = abs( sin( position.x * position.y + time / 4.0 ) );
                float blue = abs( sin( position.x * position.y + time / 3.0 ) );
                gl_FragColor = vec4( red, green, blue, 1.0 );

            }

        </script>

        <script id="fragment_shader3" type="x-shader/x-fragment">

            uniform float time;
            uniform vec2 resolution;

            varying vec2 vUv;

            void main( void ) {

                vec2 position = vUv;

                float color = 0.0;
                color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
                color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
                color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
                color *= sin( time / 10.0 ) * 0.5;

                gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );

            }

        </script>

        <script id="fragment_shader2" type="x-shader/x-fragment">

            uniform float time;
            uniform vec2 resolution;

            uniform sampler2D texture;

            varying vec2 vUv;

            void main( void ) {

                vec2 position = -1.0 + 2.0 * vUv;

                float a = atan( position.y, position.x );
                float r = sqrt( dot( position, position ) );

                vec2 uv;
                uv.x = cos( a ) / r;
                uv.y = sin( a ) / r;
                uv /= 10.0;
                uv += time * 0.05;

                vec3 color = texture2D( texture, uv ).rgb;

                gl_FragColor = vec4( color * r * 1.5, 1.0 );

            }
        </script>

        <script id="fragment_shader1" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision highp float;
            #endif

            uniform vec2 resolution;
            uniform float time;

            varying vec2 vUv;

            void main(void)
            {

                vec2 p = -1.0 + 2.0 * vUv;
                float a = time*40.0;
                float d,e,f,g=1.0/40.0,h,i,r,q;

                e=400.0*(p.x*0.5+0.5);
                f=400.0*(p.y*0.5+0.5);
                i=200.0+sin(e*g+a/150.0)*20.0;
                d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;
                r=sqrt(pow(i-e,2.0)+pow(d-f,2.0));
                q=f/r;
                e=(r*cos(q))-a/2.0;f=(r*sin(q))-a/2.0;
                d=sin(e*g)*176.0+sin(e*g)*164.0+r;
                h=((f+d)+a/2.0)*g;
                i=cos(h+r*p.x/1.3)*(e+e+a)+cos(q*g*6.0)*(r+h/3.0);
                h=sin(f*g)*144.0-sin(e*g)*212.0*p.x;
                h=(h+(f-e)*q+sin(r-(a+h)/7.0)*10.0+i/4.0)*g;
                i+=cos(h*2.3*sin(a/350.0-q))*184.0*sin(q-(r*4.3+a/12.0)*g)+tan(r*g+h)*184.0*cos(r*g+h);
                i=mod(i/5.6,256.0)/64.0;
                if(i<0.0) i+=4.0;
                if(i>=2.0) i=4.0-i;
                d=r/350.0;
                d+=sin(d*d*8.0)*0.52;
                f=(sin(a*g)+1.0)/2.0;
                gl_FragColor=vec4(vec3(f*i/1.6,i/2.0+d/13.0,i)*d*p.x+vec3(i/1.3+d/8.0,i/2.0+d/18.0,i)*d*(1.0-p.x),1.0);

            }

        </script>

        <script id="vertexShader" type="x-shader/x-vertex">

            varying vec2 vUv;

            void main()
            {
                vUv = uv;
                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                gl_Position = projectionMatrix * mvPosition;
            }

        </script>
    <script type="text/javascript">
      (function main() {
        meshes = [];

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera = new THREE.Camera( 40, windowHalfX / windowHalfY, 1, 3000 );
        camera.position.z = 4;

        cameraOrtho = new THREE.Camera();
        cameraOrtho.projectionMatrix = THREE.Matrix4.makeOrtho(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000);
        cameraOrtho.position.z = 100;

        scene = new THREE.Scene();
        sceneBG = new THREE.Scene();

        start_time = new Date().getTime();

        rtTexture1 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {min_filter: THREE.LinearFilter, mag_filter: THREE.LinearFilter});

        uniforms1 = {
          time: { type: "f", value: 1.0 },
          resolution: { type: "v2", value: new THREE.Vector2() }
        };

        uniforms2 = {
          time: { type: "f", value: 1.0 },
          resolution: { type: "v2", value: new THREE.Vector2() },
          texture: { type: "t", value: 0, texture: THREE.ImageUtils.loadTexture( "textures/disturb.jpg" ) }
        };

        uniforms2.texture.texture.wrapS = uniforms2.texture.texture.wrapT = THREE.Repeat;

        size = 0.75, mlib = [],
        params = [ [ 'fragment_shader1', uniforms1 ],  [ 'fragment_shader2', uniforms2 ], [ 'fragment_shader3', uniforms1 ], [ 'fragment_shader4', uniforms1 ] ];

        for(i = 0; i < params.length; i++ ) {

          material = new THREE.MeshShaderMaterial( {
            uniforms: params[ i ][ 1 ],
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById(params[ i ][ 0 ]).textContent
          } );

          mlib[ i ] = material;

          mesh = new THREE.Mesh( new THREE.CubeGeometry( size, size, size, 1, 1, 1, [ mlib[ i ], mlib[ i ], mlib[ i ], mlib[ i ], mlib[ i ], mlib[ i ] ], false ), new THREE.MeshFaceMaterial() );
          mesh.position.x = i - ( params.length - 1 ) / 2;
          mesh.position.y = i % 2 - 0.5;
          scene.addObject( mesh );

          meshes[ i ] = mesh;

        }

        uniforms1.resolution.value.x = window.innerWidth;
        uniforms1.resolution.value.y = window.innerHeight;

        uniforms2.resolution.value.x = window.innerWidth;
        uniforms2.resolution.value.y = window.innerHeight;

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        /*
        now = last = new Date;
        tune = 0.0;
        camera = new THREE.Camera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.x = 500;
        camera.position.y = 500;
        camera.position.z = 500;
        scene = new THREE.Scene();
        materials = [];
        for (i = 0; i < 6; i ++ ) {
          materials.push( [ new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) ] );
        }
        cube = new THREE.Mesh( new THREE.CubeGeometry(200, 200, 200, 1, 1, 1, materials), new THREE.MeshFaceMaterial() );
        cube.overdraw = true;
        scene.addObject( cube );
        cube2 = new THREE.Mesh( new THREE.CubeGeometry(200, 200, 200, 1, 1, 1, materials), new THREE.MeshFaceMaterial() );
        cube2.overdraw = true;
        cube2.position.x = cube2.position.y = cube2.position.z = -300.0;
        scene.addObject( cube2 );
        plane = new THREE.Mesh( new THREE.PlaneGeometry(200, 200), new THREE.MeshBasicMaterial( { color: 0xe0e0e0 } ) );
        plane.rotation.x = - 90 * (Math.PI / 180);
        plane.overdraw = true;
        scene.addObject( plane );
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth / 2, window.innerHeight / 2);
        document.body.appendChild( renderer.domElement );
        */

      })();
      (function simulate_and_wait() {
        (function wait() {
          return function(callback) {
            //window.setTimeout(callback, tune)
          };
        })()(simulate_and_wait);
      })();
      (function render_and_vsync() {

        renderer.context.disable(renderer.context.DEPTH_TEST);
        renderer.render(sceneBG, cameraOrtho, rtTexture1);
        renderer.context.enable(renderer.context.DEPTH_TEST);

        uniforms1.time.value += 0.05;
        uniforms2.time.value = ( new Date().getTime() - start_time ) / 1000;
        for( var i = 0; i < meshes.length; ++i ) {
          meshes[ i ].rotation.y += 0.01 * ( i % 2 ? 1 : -1 );
          meshes[ i ].rotation.x += 0.01 * ( i % 2 ? -1 : 1 );
        }
        renderer.render( scene, camera );


        /*
        now = + new Date;
        if (now != last) {
          dt = now - last;
          last = now;
          plane.rotation.z = cube.rotation.y += 0.005 * dt;
          cube.position.y = Math.sin(now * 0.01) * 100.0;
          camera.target.position = cube2.position;
        } else {
          tune += 5.0;
        }
        
        renderer.render(scene, camera);

        */


        (function vsync() {
          return window.requestAnimationFrame || 
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame || 
          window.oRequestAnimationFrame || 
          window.msRequestAnimationFrame || 
          function(callback, element){
            window.setTimeout(callback, 1000 / 60);
          };
        })()(render_and_vsync);
      })();
    </script>
  </body>
</html>
